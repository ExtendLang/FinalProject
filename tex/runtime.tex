\chapter{Extend's Runtime}

\section{Overview}
Extend's cell values are lazily evaluated, which means they need to be implemented using function pointers. For each function that the Extend developer writes, the corresponding LLVM function that is generated is essentially identical: allocate a scope object for that function call, initialize that object with the appropriate set of variable definitions and the function arguments to that scope object, and then evaluate the variables corresponding to the size assertion and the return expression for that function. All of the "individualized" code lives in what we referred to as the formula-functions; for each distinct formula, the compiler generates a corresponding function that can be called when the corresponding cell's value is needed. Each formula-function shared the same signature: the arguments were a pointer to a scope and the row and column number of the cell being evaluated, and the return value was a pointer to a value struct (which holds the type and contents of the value.)

The two main functions of our C runtime, therefore, were instantiate\_variable(), which looked at the variable definition "blueprint" and calculated the actual dimensions of the variable for that particular function call, and calculated the actual range of cells to which each formula applied; and getVal(), which determined if a particular cell value had already been calculated or not, and called the appropriate formula-function if not.

Before actually calling the main Extend entry point, our executable initializes a global array with the appropriate variable definitions for each function. When an Extend function is called, it simply copies the appropriate pointer into that array into its scope object.

Therefore, leaving aside all the variable multiplication resulting from transformations, and ignoring size assertions:
\begin{lstlisting}
  foo() {
    x := 1;
    return x;
  }
\end{lstlisting}
\medskip \noindent
would result in the LLVM equivalent of the following pseudocode (not written in any actual language) being generated:

\begin{lstlisting}
  value_p foo() {
    scope = new ExtendScope;

    // Load the apropriate set of definitions for foo
    scope->defns = global_definitions[42];

    // Create an array of pointers to variable instances; one
    // pointer per variable. Only one variable in this function
    scope->insts = new var_instance* [1];

    // getVar calls instantiate_var if that instance pointer is still NULL,
    // or just returns the pointer if it's already been instantiated.
    // The instantiated variable keeps a copy of the pointer to its scope
    var_instance *return_variable = getVar(scope, 0);

    // Get the value of cell [0,0] of return_variable
    return getVal(return_variable, 0, 0);
  }
\end{lstlisting}
\medskip \noindent

Since the newly initialized scope object would have held all NULL pointers for the instances, getVar() would have ended up calling instantiate\_variable, which would have determined that x had 1 row and 1 column; there was only a single formula for x, applying to all cells of x; and that that formula corresponded to the function pointer indicated in the variable definition.
When getVal was called, the value in the [0,0]th cell would similarly have been NULL. Therefore, getVal() would have determined the appropriate formula, and then called that formula-function with a pointer to the scope, and (0,0) for the row and column.
