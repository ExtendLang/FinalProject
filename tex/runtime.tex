\chapter{Extend's Runtime}

\section{Overview}
Extend's cell values are lazily evaluated, which means they need to be implemented using function pointers. For each function that the Extend developer writes, the corresponding LLVM function that is generated is essentially identical: allocate a scope object for that function call, initialize that object with the appropriate set of variable definitions and the function arguments to that scope object, and then evaluate the variables corresponding to the size assertion and the return expression for that function. All of the "individualized" code lives in what we referred to as the formula-functions; for each distinct formula, the compiler generates a corresponding function that can be called when the corresponding cell's value is needed. Each formula function shared the same signature: the arguments were a pointer to a scope and the row and column number of the cell being evaluated, and the return value was a pointer to a value struct (which holds the type and contents of the value.)

The two main functions of our C runtime, therefore, were instantiate_variable(), which looked at the variable definition "blueprint" and calculated the actual dimensions of the variable for that particular function call, and calculated the actual range of cells to which each formula applied; and getVal(), which determined if a particular cell value had already been calculated or not, and called the appropriate formula-function if not.
